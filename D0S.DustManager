:global double dust_data
; ore_tier is offset by 10, so that we can avoid having to initialize it
:local int ore_tier
:local string dust_multipliers
:local double acc
:local int i

wakeup()
open.factory()

isopen("factory")

; Initialize multipliers from a string. This is annoying because we don't
; have native string->double parsing, but we can pull it off in 3 lines
; with some very fiddly expressions.

dust_multipliers = "1 1 .625 .5 .1 .1 .05"
; "i" combines the position in the string with the tier currently being
; initialized. It also stores the position of the dot, needed to properly
; handle the decimals. The encoding is pos + tier * 1000 + dot * 100000.
; (I.e. the string can only be 1000 long.)
; "dot" is offset by 1 because 0 is a sentinel value that means "no dot seen".
; "tier" technically only needs room for 10 values, but we make room for 100
; so that there's a sentinel at the end, and also to make this easy to
; incorporate in other things.
#pos (i%1000)
#tier (i/1000 % 100)
#dotpos (i/100000)
#char sub(dust_multipliers, {pos}, 1)
#prevchar sub(dust_multipliers, {pos} - 1, 1)
#nextchar sub(dust_multipliers, {pos} + 1, 1)
#isspace ({pos} >= len(dust_multipliers) | {char} == " ")
#nest2_9(macro, final) {{macro}(2,{{macro}(3,{{macro}(4,{{macro}(5,{{macro}(6,{{macro}(7,{{macro}(8,{{macro}(9,{final})})})})})})})})}
#charvalue i2d(index("123456789", {char}, 0) + 1)

; Everything in this loop is tied up in checking for if the current character
; is a space, or (mostly equivilantly) if we've run off the end of the string.
; This condition is {isspace}. When we hit a space, we transfer the
; accumulator to the appropriate buffer (perhaps redundantly, if there are
; multiple spaces in a row.) Otherwise, we keep building the accumulator.

; Mostly the accumulator is multiplied by 10 and then the current digit is
; added. However, there are wrinkles: If this is the first non-space
; character, acc will be cleared instead of multiplied. The dot character
; counts as zero and multiplies by 1, since it has no real value. And we
; have to adjust the value for the dotpos if this is the last character
; before a space or the end of the string.

; Adjusting "i" is a bit simpler: The pos component always increases by one.
; "tier" increases when transitioning to a non-space character, or when we're
; off the end of the string. (The latter allows for the string to be short,
; and missing values will be duplicated at the end.) "dotpos" gets set directly
; if the current character is a dot, otherwise it gets reset to 0 when the
; current char is a space.
init_multipliers:
lds(if({isspace}, "buffer".({tier} + 1), "acc"), if({isspace}, acc, (acc * if({prevchar} == " " | {pos} == 0, 0., if({char} == ".", 1., 10.)) + {charvalue}) * if(({nextchar} != " " & {pos} + 1 != len(dust_multipliers)) | {dotpos} == 0, 1., 0.1^i2d({pos} + 1 - {dotpos}))))
i = {pos} + 1 + ({tier} + if({isspace} & {nextchar} != " ", 1, 0)) * 1000 + if({isspace}, 0, if({char} == ".", {pos} + 1, {dotpos})) * 100000
gotoif(init_multipliers, {tier} <= 9)

; The overall plan is to count down through the ores, so that the best ones
; (with the least count) get processed first, but to count up through the
; lumps, because that "sweeps" the wave forward up the tiers.
top:
; "dust_data" combines both the amount of dust we saw when we started
; processing this tier, and the lump processing tier. We combine them into
; one variable so it only takes one action to set them.
; The scheme is that dust_data % 9 is the tier, and dust_data / 9 is the
; amount of dust at (tier + 1). Because we're storing this in an double,
; we need to take care to stay in the range where we have exact integer math,
; but fortunately no one is likely to have that much dust (right?)
; We keep the amount of dust at the start because if it's <= the safety
; buffer, we'll only go 10 below it. This gives us 10 lumps to hand to the
; mixer, but avoids destroying all the saved dust while we wait
; for a large amount of lumps to process. As we process more lumps, the
; amount of queued lumps will grow, since all the produced dust will get
; turned back into lumps (until we run out of the base tier dust buffer).

; We put an extra ternary in here to handle initializing dust_data.
; We need the extra guard for isopen("factory"), otherwise there are
; spurious advances when the window is closed (because active() returns false).

; This seems like it's separated from the rest of the lump code, but it's
; actually not, it's just wrapped around on the other side of the goto.
; It actually comes "after", but you see it here before so that dust_data
; is initialized if it's zero.

#ore_pair "ore", ore_tier + 10
#next_tier ((if(dust_data == 0., 0., dust_data + 1.)) % 9.)

dust_data = if(dust_data > 0. & (active("mixer") | isopen("factory") == false), dust_data, min(count("dust", d2i({next_tier}) + 2), 1000799917193442.) * 9. + {next_tier})

produce({ore_pair}, count({ore_pair}), "crusher")
ore_tier = if(active("crusher"), ore_tier, if(ore_tier > -9, ore_tier - 1, 0))

; These expressions calculate how much dust to keep. #dust_value calculates
; the value of all your dust in T1-equivilant units (i.e. if you
; down-converted it all). This assumes you can upconvert at Chemical Lumps
; prices (but it will adjust OK if you can't). #denominator is calculating
; the same downconverted value for the sum of dust_multipliers, except it
; cuts off the expression once it reaches a tier where you don't have dust.
; This prevents the higher tiers from overwhelming the result when you don't
; have access to them yet.
; The ratio between them tells how to scale a particular entry of
; dust_multipliers into a target value.

#count_nest(value, rest) (count("dust", {value}) + 4. * {rest})
#dust_value {count_nest(1, {nest2_9(count_nest, count("dust", 10))})}
#denom_nest(value, rest) if(count("dust", {value}) == 0., 0., 4.) * (ldg("buffer{value}") + {rest})
#denominator (ldg("buffer1") + {nest2_9(denom_nest, if(count("dust", 10) == 0., 0., 4.) * ldg("buffer10"))})
#lump_tier(offset) (d2i(dust_data % 9.) + {offset})
#target(offset) (ldg("buffer" . {lump_tier({offset})}) * {dust_value} / {denominator})

; We always save one dust on the producing side, so that dust ordering doesn't
; get messed up in the inventory.
; The "- 4" on the consuming side is to adjust for Chemical Lumps.
; That way, in the terminal case it'll hit the safety target exactly. If you
; don't have lumps, you'll be up to 3 under the target. However, we always
; ensure that you'll leave one leftover no matter what.

craft("lump", {lump_tier(1)}, min(count("dust", {lump_tier(2)}) - max(1., min({target(2)}, floor(dust_data/9.) - 100.)), (count("dust", {lump_tier(1)}) - max({target(1)} - 4., 1.)) / 8.))
produce("lump", {lump_tier(1)}, count("lump", {lump_tier(1)}), "mixer")

gotoif(top, isopen("factory"))
