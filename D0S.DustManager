:global int lump_tier
; ore_tier is offset by 10, so that we can avoid having to initialize it
:local int ore_tier
:local double dust_safety_buffer

#ore_pair "ore", ore_tier + 10

open.factory()

; The overall plan is to count down through the ores, so that the best ones
; (with the least count) get processed first, but to count up through the
; lumps, because that "sweeps" the wave forward up the tiers.

dust_safety_buffer = 200.
top:
produce({ore_pair}, count({ore_pair}), "crusher")
ore_tier = if(active("crusher"), ore_tier, if(ore_tier > -9, ore_tier - 1, 0))
craft("lump", lump_tier, min(count("dust", lump_tier + 1) - dust_safety_buffer, (count("dust", lump_tier) - dust_safety_buffer) / 8.))
produce("lump", lump_tier, count("lump", lump_tier), "mixer")
; We put an extra ternary in here to handle initializing lump_tier lazily.
; It'll spend one iteration on a useless value, that's OK.
; We need the extra guard for isopen("factory"), otherwise there are
; spurious advanced when the window is closed (because active() returns false).
lump_tier = if(lump_tier < 1, 1, if(active("mixer") | isopen("factory") == false, lump_tier, if(lump_tier < 9, lump_tier + 1, 1)))
gotoif(top, isopen("factory"))
