:local int dust_tier
:local string dust_multipliers
:local double acc
:local int i
:local int state
:local double ore_buffer

wakeup()
open.factory()

isopen("factory")

; Amount of ore to save at each tier. Ore will only be saved if there is
; more dust than ore, otherwise it will be crushed anyway (so that saving
; ore doesn't prevent you from progressing.) This function exists to allow
; for scanning ore with the Crafter.
ore_buffer = 1000.

; Initialize multipliers from a string. This is annoying because we don't
; have native string->double parsing, but we can pull it off in 3 lines
; with some very fiddly expressions.

dust_multipliers = "1 1 .625 .5 .07872 .06312 .01 .01 .0021"
; "i" combines the position in the string with the tier currently being
; initialized. It also stores the position of the dot, needed to properly
; handle the decimals. The encoding is pos + tier * 1000 + dot * 100000.
; (I.e. the string can only be 1000 long.)
; "dot" is offset by 1 because 0 is a sentinel value that means "no dot seen".
; "tier" technically only needs room for 10 values, but we make room for 100
; so that there's a sentinel at the end, and also to make this easy to
; incorporate in other things.
#pos (i%1000)
#tier (i/1000 % 100)
#dotpos (i/100000)
#char sub(dust_multipliers, {pos}, 1)
#prevchar sub(dust_multipliers, {pos} - 1, 1)
#nextchar sub(dust_multipliers, {pos} + 1, 1)
#isspace ({pos} >= len(dust_multipliers) | {char} == " ")
#nest2_9(macro, final) {{macro}(2,{{macro}(3,{{macro}(4,{{macro}(5,{{macro}(6,{{macro}(7,{{macro}(8,{{macro}(9,{final})})})})})})})})}
#charvalue i2d(index("123456789", {char}, 0) + 1)

; Everything in this loop is tied up in checking for if the current character
; is a space, or (mostly equivilantly) if we've run off the end of the string.
; This condition is {isspace}. When we hit a space, we transfer the
; accumulator to the appropriate buffer (perhaps redundantly, if there are
; multiple spaces in a row.) Otherwise, we keep building the accumulator.

; Mostly the accumulator is multiplied by 10 and then the current digit is
; added. However, there are wrinkles: If this is the first non-space
; character, acc will be cleared instead of multiplied. The dot character
; counts as zero and multiplies by 1, since it has no real value. And we
; have to adjust the value for the dotpos if this is the last character
; before a space or the end of the string.

; Adjusting "i" is a bit simpler: The pos component always increases by one.
; "tier" increases when transitioning to a non-space character, or when we're
; off the end of the string. (The latter allows for the string to be short,
; and missing values will be duplicated at the end.) "dotpos" gets set directly
; if the current character is a dot, otherwise it gets reset to 0 when the
; current char is a space.
init_multipliers:
lds(if({isspace}, "buffer".({tier} + 1), "acc"), if({isspace}, acc, (acc * if({prevchar} == " " | {pos} == 0, 0., if({char} == ".", 1., 10.)) + {charvalue}) * if(({nextchar} != " " & {pos} + 1 != len(dust_multipliers)) | {dotpos} == 0, 1., 0.1^i2d({pos} + 1 - {dotpos}))))
i = {pos} + 1 + ({tier} + if({isspace} & {nextchar} != " ", 1, 0)) * 1000 + if({isspace}, 0, if({char} == ".", {pos} + 1, {dotpos})) * 100000
gotoif(init_multipliers, {tier} <= 9)

; The overall plan is to count down through the ores, so that the best ones
; (with the least count) get processed first, and to count down through
; the lumps as well. We process lumps in "packets" that are based on a
; power of the stack size, which ensures that uptiering
; doesn't consume too much dust while processing but also allows
; for the chunks to process for a considerable time.
; This also makes for a simple expression that equals 0 when the size
; is 1 (so that we don't use the last dust), and 1 when the size is 2
; (so that we do start immediately after that point.)

; The tier variable is a local, so the process can be restarted from
; the top if it's taking too long.
top:

; Nested expressions for calculating the tier of ore to crush. This factors in
; the need to save 1000 ore based on ore_buffer, and returns
; 0 if there is no crushable ore.
#orecount_cond(value) (count("ore", {value}) <= min(ore_buffer, count("dust", {value})))
#orestate_nest(value, rest) if({orecount_cond(10 - {value})}, {rest}, 10 - {value})
#dust_inc if(active("mixer"), 0, 11)
#orestate if(active("crusher"), {dust_inc}, {orestate_nest(0,{orestate_nest(1,{nest2_9(orestate_nest,{dust_inc})})})})

; The main state calculation. We first calculate whether ore needs to be
; crushed, and if it does not, we possibly increment the current dust that is
; being mixed.

; The dust_tier for mixing and ore_tier for crushing are stored together in state.
; Mixing will only occur if ore_tier is 0, since crushing takes priority.
; (Generally the mixing will happen in the next iteration.)

#raw_dust_tier (state / 11)
#curr_dust_tier ((({raw_dust_tier} + 8) % 9) + 1)
#next_dust_tier ((({raw_dust_tier} + 8 )% 9) + 2)
#ore_tier (state % 11)
#has_ore ({ore_tier} != 0)

state = ({raw_dust_tier} * 11 + {orestate}) % 99

; These expressions calculate how much dust to uptier. It used to be a more
; complicated expression that calculated everything in T1-equivilant units,
; (i.e. if you down-converted it all), but that isn't actually needed: Everything
; works (better actually) if you just make local decisions based on the ratios
; between the current and next tier.
; In both cases, Ore Lumps are also counted as dust, so that unmixed lumps don't
; throw off the calculations. We know that currently processing lumps won't be
; an issue, because we only craft when the mixer is empty.

#count_dust_and_lumps(dust_tier) (count("lump", {dust_tier} - 1) + count("dust", {dust_tier}))
#needed_by_ratio(dust_tier) (({count_dust_and_lumps({dust_tier})} * ldg("buffer" . ({dust_tier} + 1))\
  - {count_dust_and_lumps({dust_tier} + 1)} * ldg("buffer" . {dust_tier}))\
  / (ldg("buffer" . {dust_tier}) + 8. * ldg("buffer" . ({dust_tier} + 1))))

; We always save one dust on the producing side, so that dust ordering doesn't
; get messed up in the inventory.
; We produce lumps in chunks. We consume up to 5% of the destination;
; this allows for large-ish mixing regardless of stack size, and
; dynamically adjusts well.
; Not adding more to the mixer when it's running greatly reduces
; complications. We just move on to the next tier when it's done,
; and come back around soon enough.
; The "+ 0.5" on the consuming side is to adjust for Chemical Lumps.
; That way, in the terminal case it'll hit the safety target exactly. If you
; don't have lumps, you'll be up to 3 under the target. However, we always
; ensure that you'll leave one leftover no matter what.

craft(if({has_ore} || active("mixer"), "", "lump"), {curr_dust_tier}, min(0.999 * count("dust", {next_dust_tier})^ 0.84, {needed_by_ratio({curr_dust_tier})} + 0.5))
produce(if({has_ore}, "ore", if(active("mixer"), "", "lump")),\
  if({has_ore}, {ore_tier}, {curr_dust_tier}),\
  if({has_ore}, max(count("ore", {ore_tier}) - ore_buffer, 1. + (count("ore", {ore_tier}) - count("dust", {ore_tier})) / 3.), count("lump", {curr_dust_tier})),\
  if({has_ore}, "crusher", "mixer"))

gotoif(top, isopen("factory"))
