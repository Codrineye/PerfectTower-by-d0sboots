:local int dust_tier
:local string dust_multipliers
:local double acc
:local int i

wakeup()
open.factory()

isopen("factory")

; Initialize multipliers from a string. This is annoying because we don't
; have native string->double parsing, but we can pull it off in 3 lines
; with some very fiddly expressions.

dust_multipliers = "1 1 .625 .5 .07872 .06312 .01 .01 .0021"
; "i" combines the position in the string with the tier currently being
; initialized. It also stores the position of the dot, needed to properly
; handle the decimals. The encoding is pos + tier * 1000 + dot * 100000.
; (I.e. the string can only be 1000 long.)
; "dot" is offset by 1 because 0 is a sentinel value that means "no dot seen".
; "tier" technically only needs room for 10 values, but we make room for 100
; so that there's a sentinel at the end, and also to make this easy to
; incorporate in other things.
#pos (i%1000)
#tier (i/1000 % 100)
#dotpos (i/100000)
#char sub(dust_multipliers, {pos}, 1)
#prevchar sub(dust_multipliers, {pos} - 1, 1)
#nextchar sub(dust_multipliers, {pos} + 1, 1)
#isspace ({pos} >= len(dust_multipliers) | {char} == " ")
#nest2_9(macro, final) {{macro}(2,{{macro}(3,{{macro}(4,{{macro}(5,{{macro}(6,{{macro}(7,{{macro}(8,{{macro}(9,{final})})})})})})})})}
#charvalue i2d(index("123456789", {char}, 0) + 1)

; Everything in this loop is tied up in checking for if the current character
; is a space, or (mostly equivilantly) if we've run off the end of the string.
; This condition is {isspace}. When we hit a space, we transfer the
; accumulator to the appropriate buffer (perhaps redundantly, if there are
; multiple spaces in a row.) Otherwise, we keep building the accumulator.

; Mostly the accumulator is multiplied by 10 and then the current digit is
; added. However, there are wrinkles: If this is the first non-space
; character, acc will be cleared instead of multiplied. The dot character
; counts as zero and multiplies by 1, since it has no real value. And we
; have to adjust the value for the dotpos if this is the last character
; before a space or the end of the string.

; Adjusting "i" is a bit simpler: The pos component always increases by one.
; "tier" increases when transitioning to a non-space character, or when we're
; off the end of the string. (The latter allows for the string to be short,
; and missing values will be duplicated at the end.) "dotpos" gets set directly
; if the current character is a dot, otherwise it gets reset to 0 when the
; current char is a space.
init_multipliers:
lds(if({isspace}, "buffer".({tier} + 1), "acc"), if({isspace}, acc, (acc * if({prevchar} == " " | {pos} == 0, 0., if({char} == ".", 1., 10.)) + {charvalue}) * if(({nextchar} != " " & {pos} + 1 != len(dust_multipliers)) | {dotpos} == 0, 1., 0.1^i2d({pos} + 1 - {dotpos}))))
i = {pos} + 1 + ({tier} + if({isspace} & {nextchar} != " ", 1, 0)) * 1000 + if({isspace}, 0, if({char} == ".", {pos} + 1, {dotpos})) * 100000
gotoif(init_multipliers, {tier} <= 9)

; The overall plan is to count down through the ores, so that the best ones
; (with the least count) get processed first, and to count down through
; the lumps as well. We process lumps in "packets" that max out at
; 5% of the destination's amount, which ensures that uptiering
; doesn't consume too much dust while processing but also allows
; for the chunks to process for a considerable time.

; The tier variable is a local, so the process can be restarted from
; the top if it's taking too long.
top:

; We need the extra guard for isopen("factory"), otherwise there are
; spurious advances when the window is closed (because active() returns false).

; This seems like it's separated from the rest of the lump code, but it's
; actually not, it's just wrapped around on the other side of the goto.
; It actually comes "after", but you see it here before so that dust_tier
; is initialized if it's zero.

#next_tier if(dust_tier <= 1, 9, dust_tier - 1)

dust_tier = if((active("mixer") | isopen("factory") == false), dust_tier, {next_tier})

; The core expression that determines if the produce action is dealing
; with ore or lumps. Unfortuantely, this has to get fanned out x4 across
; all the parameters.
#orelump_nest(value, rest) count("ore", {value}) == 0. && {rest}
#ore_or_lump(ore, lump) if(active("crusher") || ({orelump_nest(1,{nest2_9(orelump_nest,count("ore", 10) == 0.)})}),{lump}, {ore})
#ore_action(expr) {lua(\
  local expr = [[{expr}]];\
  local acc = {};\
  for i = 10, 1, -1 do\
    local subbed = expr:gsub("val", i);\
    if i ~= 1 then\
      acc[#acc+1] = 'if(count("ore", ' .. i .. ') > 0., ' .. subbed .. ', ';\
	else\
	  acc[#acc+1] = subbed;\
	end\
  end\
  for i = 9, 1, -1 do\
    acc[#acc+1] = ')';\
  end\
  return table.concat(acc);\
)}
#ore_or_lump_tier {ore_or_lump({ore_action(val)}, {lump_tier(0)})}
#ore_or_lump_count {ore_or_lump({ore_action(count("ore", val))}, count("lump", {lump_tier(0)}))}

; These expressions calculate how much dust to keep. #dust_value calculates
; the value of all your dust in T1-equivilant units (i.e. if you
; down-converted it all). This assumes you can upconvert at Chemical Lumps
; prices (but it will adjust OK if you can't). #denominator is calculating
; the same downconverted value for the sum of dust_multipliers, except it
; cuts off the expression once it reaches a tier where you don't have dust.
; This prevents the higher tiers from overwhelming the result when you don't
; have access to them yet.
; The ratio between them tells how to scale a particular entry of
; dust_multipliers into a target value.

#count_nest(value, rest) (count("dust", {value}) + 4. * {rest})
#dust_value {count_nest(1, {nest2_9(count_nest, count("dust", 10))})}
#denom_nest(value, rest) if(count("dust", {value}) == 0., 0., 4.) * (ldg("buffer{value}") + {rest})
#denominator (ldg("buffer1") + {nest2_9(denom_nest, if(count("dust", 10) == 0., 0., 4.) * ldg("buffer10"))})
#lump_tier(offset) (dust_tier {lua(if {offset} == 0 then return "" else return "+ " .. [[{offset}]] end)})
#target(offset) (ldg("buffer" . {lump_tier({offset})}) * {dust_value} / {denominator})

; We always save one dust on the producing side, so that dust ordering doesn't
; get messed up in the inventory.
; We produce lumps in chunks. We consume up to 5% of the destination;
; this allows for large-ish mixing regardless of stack size, and
; dynamically adjusts well.
; Not adding more to the mixer when it's running greatly reduces
; complications. We just move on to the next tier when it's done,
; and come back around soon enough.
; The "- 4" on the consuming side is to adjust for Chemical Lumps.
; That way, in the terminal case it'll hit the safety target exactly. If you
; don't have lumps, you'll be up to 3 under the target. However, we always
; ensure that you'll leave one leftover no matter what.

craft(if(active("mixer"), "", "lump"), {lump_tier(0)}, min(count("dust", {lump_tier(1)}) - max(1., min({target(1)}, 0.95 * count("dust", {lump_tier(1)}))), (count("dust", {lump_tier(0)}) - max({target(0)} - 4., 1.)) / 8.))
produce_loop:
produce({ore_or_lump("ore", "lump")}, {ore_or_lump_tier}, {ore_or_lump_count}, {ore_or_lump("crusher", "mixer")})

goto(if(isopen("factory"), if(active("mixer"), produce_loop, top), 99))
