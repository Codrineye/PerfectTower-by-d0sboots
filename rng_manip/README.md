# RNG Manipulation Library

If you just want the example script that gets stacks of Rak's Curse, you can
get that here:

`D0S.RakStak 2 1 15`

```
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
```

It automatically starts in tower testing, will exit if you don't have Rak's Curse in your BP, and will also exit
as soon as it finished getting 5 stacks, which should only take a few seconds. Aside from the parts that are macro-generated
by the rng\_manip library, it should be pretty straightforward to understand and incorporate yourself if you want to.

It'll be easier to understand by looking at the [source code](D0S.RakStak.tpt2).

## Library workspace

To use the library yourself, you'll need to import the source. The workspace
import comes with two example scripts, which you can delete if you don't want/need.
Explanation for how to use the library is in the comments of the rnglib script.

```
{"workspaces":{"rng_manip":[["rnglib","; This library exists to do RNG manipulation in TPT2. If you don't know what RNG manipulation is,\n; you can find plenty of info on the web, but also this library is probably not for you.\n\n; Stub needed to make the macros not error during the examples\n{lua(function rng_code() end)}\n\n; There are three sets of macros defined in this library. The first is the 3-part rng_init sequence:\n#rng_init1 {lua(return rng_code(\"init1\"))}\n#rng_init2 {lua(return rng_code(\"init2\"))}\n#rng_init3(label) {lua(return rng_code(\"init3\",[[{label}]]))}\n; To use these, place this sequence *immediately* before the event you want to manipulate.\n; {rng_init1}\n; {rng_init2}\n; {rng_init3(continue)}\n; continue:\n;\n; The last one takes a label to goto to when it is done. You can define the label on the next\n; line if you just want it to continue there. You can also use more complicated conditional\n; expressions if you want.\n;\n; It is important that you run this in the same frame as the event you are trying to manipulate,\n; ideally right before, so that other calls to the rng do not happen in-between.\n;\n; If you need to re-initialize the state, jump to :rng_reinit. Don't include this block twice,\n; because it expands to a very large amount of code.\n\n; To simulate future rolls of the rng, use this macro:\n#rng_next {lua(return rng_code(\"next\"))}\n; You will need to call this (at least) once before calling rng_getint. Every call to {rng_next}\n; should correspond to one call to the RNG (generally via rnd()), except for the last one(s) which\n; you want to save for the actual in-game event(s) that are rolling the RNG.\n\n; This macro converts the simulated state to a 32-bit integer.\n#rng_getint {lua(return rng_code(\"getint\"))}\n#rng_getdouble {lua(return rng_code(\"getdouble\"))}\n; Don't forget that you need one call to {rng_next} before the result will be valid.\n; {rng_getint} will potentially be negative if the high bit is set. {rng_getdouble} avoids\n; this issue by using a double, so the result will always be a non-negative integer.\n\n; This simulates the same behavior as the rnd() function.\n#rng_getrange(min, max) {lua(return rng_code(\"getrange\",[[{min}]],[[{max}]]))}\n; The range is inclusive. Just like with {rng_getint}, {rng_next} needs to be called\n; before this is valid.\n\n; ==========================================================================================\n; ================================= IMPLEMENTATION DETAILS =================================\n; ==========================================================================================\n\n; Change this to \"global\" for debugging\n#rng_local local\n\n\n; The 128-bit state of the rng, stored as 128 \"1\"s and \"0\"s.\n; It is exactly as pathetic as it sounds, but it is actually most efficient to compute\n; xor and bitshifting with numbers in string form, because we can do xor via\n; precomputed tables and bitshifts become (sub)string manipulation.\n; You'd think the same could be done with integers with * and /, but the fact that we only\n; have signed integers makes everything too awful.\n; This is used by {rng_next} to compute the next state, and {rng_getint} to convert to a number.\n; You can copy this elsewhere and restore it later if you want to simulate multiple rng seeds at once.\n:{rng_local} string rng_state\n\n; A temporary variable used during int-to-binary conversion. A double is used to avoid issues\n; with the sign bit.\n:{rng_local} double rng_r\n\n\n; The structure of the code is broken up into multiple Lua functions, to allow regular\n; comments to explain them at the top of each. Lua functions are used to construct the code,\n; instead of regular macros, so that we could define our user-visible macros such as\n; {rng_init1}, {rng_next} etc. at the top without having to give the full implementation;\n; instead, a stub implementation was given and then the function is re-implemented at the\n; bottom of the file here. This allows us to use the macros freely in comments, since macros\n; are always expanded, where otherwise we could not comment on them before they were defined.\n; As a side benefit, before the full definition takes effect they will expand to nothing,\n; which is very fast to evaluate.\n\n; This constructs the data string that will be used to initialize our lookup tables.\n; The data string is 256 entries, each 23 bytes long:\n; * 8 bytes for the name suffix of \"rng_from\"\n; * 11 bytes for the entire name of the xor table (entries like \"0001xor0110\")\n; * 4 bytes for the value of the xor table\n; All these strings are binary strings (the characters \"0\" and \"1\"), except also containing\n; \"xor\" in the name for the xor table.\n{lua(function rng_getLookupString()\\\n  local codetable = {}\\\n  local conv4 = {}\\\n  for i=0, 15 do\\\n    local bin = \"\"\\\n    local idx = i\\\n    for j=0, 3 do\\\n      bin = bin .. string.char((i>>3) + 48)\\\n      i = (i<<1) & 15\\\n    end\\\n    conv4[idx] = bin\\\n  end\\\n  for i=0, 255 do\\\n    codetable[i*3+1] = conv4[i>>4] .. conv4[i&15]\\\n    codetable[i*3+2] = conv4[i>>4] .. \"xor\" .. conv4[i&15]\\\n    codetable[i*3+3] = conv4[(i>>4) ~ (i&15)]\\\n  end\\\n  return table.concat(codetable)\\\nend\\\n)}\n\n; This constructs the code for the three rng_init macros. The code for these is truly awful,\n; because what should be ~7 lines has been crammed into the minimum possible of 3 lines to\n; save space in user code.\n;\n; At a high level, {rng_init1} is a local.int.set, {rng_init2} is a local.string.set,\n; and {rng_init3()} is a goto. Each of these performs multiple different functions depending on\n; the phase of execution; they act together as a state machine in order to initialize everything\n; that needs initialization.\n;\n; The first phase is setting the \"rng_from\" and \"xor\" tables. Both of these tables have 256 entries,\n; and the data for them is encoded together in a string that we calculate and store as \"codetable\".\n; In this phase, we first assign the codetable data to rng_state, and then use entries from it to\n; set rng_from (an double table) and xor (a string table). We use substring to discard the front of\n; rng_state, which is the current working entry, to both load a new entry and also because the length\n; of rng_state also functions as the way to calculate the value we assign to rng_from.\n;\n; The second phase is used to read 4 values from the rng and convert them into individual bits.\n; It lasts for 128 iterations as a result. We use either\n; contains(local.string.get(\"1111xor1111\", \"0\")) (the final table entry) or\n; contains(rng_state, \"xor\") to determine when the first phase is over;\n; the two have slight differences at both the start and end of phase 1 which dictate the use\n; of one or the other in specific places.\n;\n; Reading bits is relatively straightforward: A value from rnd() is stored in rng_r and then\n; is multiplied by an appropriate power of 2 to check the sign bit. There is an additional quirk\n; where if the value is exactly 0, it indicates a condition where we have to restart the process.\n; This is because the nature of rnd() is that it adds one to range_max, so there is a hole where\n; both 0 and 2^32-1 map to the same value and we cannot distinguish them. Since this is very\n; rare, we just restart in this case and roll again.\n;\n; Tricks that are used: Since contains(\"\", \"\") is true, contains(\"\", var) is a cheap test for\n; if a variable is unset. Also, since if() and boolean logic have the same number of nodes,\n; sometimes ternaries are used to slightly optimize node counts.\n{lua(function rng_codeCacheSetInit(cache)\\\n  local codetable = rng_getLookupString()\\\n--[[\\\nIf we are in phase 1, set rng_from appropriately. If we are in phase 2, get a new rng value\\\nand save it in rng_r. We add back the minimum value to get the raw bits. We're using\\\na double to avoid issues with the sign bit.\\\nThere is one wrinkle in that the very first iteration will write 256\\\nto \"rng_from\" (not technically part of the table), but this is harmless.\\\nThis is the simplest line, because the goto skips it whenever it isn't needed.\\\n]]\\\n  cache.init1 = [[\\\nrng_init: {rng_local}.double.set(\\\n  if(\\\n    contains({rng_local}.string.get(\"1111xor1111\"), \"0\"),\\\n    \"rng_r\",\\\n    \"rng_from\" . sub(rng_state, 0, 8)\\\n  ),\\\n  if(\\\n    contains({rng_local}.string.get(\"1111xor1111\"), \"0\"),\\\n    i2d(rnd(-2147483648, 2147483646)) + 2147483648.,\\\n    i2d(256 - len(rng_state) / 23)\\\n  )\\\n)]]\\\n\\\n--[[\\\nThis line does the bulk of the work, and thus is the most complicated. It gets called a total\\\nof 641 times: 513 times in phase 1 (twice per value, and one for initial init) and 128 times in phase 2.\\\nIn phase 1, the sequence is that first line 1 is called to set rng_from, then this line sets\\\nthe xor value. Once the xor value is set, this line is looped again to shorten rng_state and\\\nmove to the next entry.\\\nIn phase 2, the size of rng_state is used to determine which bit to select by multiplying\\\nby a power of 2. Because 2^31 won't fit as an integer, and the arithmetic.int() function\\\nthrows an exception instead of wrapping it to negative, we need to special-case that value.\\\nSeveral extra quirks: If rng_r is 0, we reset state because of the ambiguity mentioned above.\\\nThis also covers the case of the last phase 1 loop, because rng_r is 0 by default.\\\nAlso reset when the state is size 128 (meaning we are calling back into this code\\\nafter prior initialization, to get a new set of random numbers).\\\n]]\\\n  cache.init2 = string.format([[\\\nrng_reinit: {rng_local}.string.set(\\\n  if(\\\n    contains(\"\", {rng_local}.string.get(sub(rng_state, 8, 11))),\\\n    if(\\\n      contains({rng_local}.string.get(\"1111xor1111\"), \"0\") || contains(\"\", rng_state),\\\n      \"rng_state\",\\\n      sub(rng_state, 8, 11)\\\n    ),\\\n    \"rng_state\"\\\n  ),\\\n  if(\\\n    contains({rng_local}.string.get(\"1111xor1111\"), \"0\"),\\\n    if(\\\n      rng_r == 0. || len(rng_state) >= 128,\\\n      \"\",\\\n      rng_state . if(\\\n        rng_r * (2.^i2d(len(rng_state) %% 32)) %% (2.^32.) >= (2.^31.),\\\n        \"1\",\\\n        \"0\"\\\n      )\\\n    ),\\\n    if(\\\n      contains(\"\", {rng_local}.string.get(sub(rng_state, 8, 11))),\\\n      if(\\\n        contains(\"\", rng_state),\\\n        \"%s\",\\\n        sub(rng_state, 19, 4)\\\n      ),\\\n      sub(rng_state, 23, 99999)\\\n    )\\\n  )\\\n)]], codetable)\\\n\\\n--[[\\\nContinue the loop at the appropriate line. We use contains(rng_state, \"xor\") to check for\\\nphase 1 here, because has the behavior we want at phase end: After the last loop, we want to\\\nstill be in phase 1 until the state has been cleared, which this test does.\\\nIn phase 1, we jump to the first line when the table values need to be set, othewise we skip\\\nstraight to line 2 to advance to the next table entry. (This also works at the end of the phase.)\\\nIn phase 2, we jump to the first line only when we need a new rng entry, which is every 32 bits.\\\nOtherwise, we loop to line 2. The exit condition is when we have filled all 128 bits, which\\\nuses the string EXTERNAL_LABEL to be replaced in rng_code().\\\n]]\\\ncache.init3 = [[\\\ngoto(\\\n  if(\\\n    contains(rng_state, \"xor\"),\\\n    if(\\\n      contains(\"\", {rng_local}.string.get(sub(rng_state, 8, 11))),\\\n      rng_init,\\\n      rng_reinit\\\n    ),\\\n    if(\\\n      len(rng_state) % 32 == 0,\\\n      if(len(rng_state) == 128, EXTERNAL_LABEL, rng_init),\\\n      rng_reinit\\\n    )\\\n  )\\\n)\\\n]]\\\n;end\\\n)}\n\n; Construct the {rng_getint} code. Because of the 8-bit lookup table in rng_from, we can\n; convert binary strings to numbers by looking up just 4 substrings and using multiplication\n; by 256 to shift them into the appropriate place. The upper bit may overflow into the sign\n; bit, but we want that in this case.\n; The extra balancing parens in comments are needed to deal with a deficiency\n; in the editor's macro parsing.\n{lua(function rng_codeCacheSetGetInt(cache)\\\n  --[[Balancing paren (]]\\\n  local res = {}\\\n  for offset = 96, 120, 8 do\\\n    res[#res+1] = string.format([[{rng_local}.double.get(\"rng_from\".sub(rng_state,%d,8)))]], offset)\\\n  end\\\n  cache.getdouble = \"((((\" .. table.concat(res, \" * 256. + \")\\\n  local first = table.remove(res, 1)\\\n  cache.getint = \"(d2i(\" .. first .. \" * 16777216 + d2i(((\" .. table.concat(res, \" * 256. + \") .. \")\"\\\n  --[[Balancing parens ))))))))]]\\\n;end\\\n)}\n\n; Construct {rng_next}.\n; This is simply Margsaglia's xorshift128, modified to deal with the fact\n; that we're using a single 128-bit string and doing all the work in parallel.\n; Note that our representation is big-endian, i.e. the high bits come first and on the left.\n; This means string indexing is opposite from how you usually expect: character 0 is the\n; highest-order bit.\n; In pseudocode, xorshift128 is:\n; s = rng_state[96..128]\n; t = rng_state[0..32]\n; t ^= t << 11\n; t ^= t >> 8\n; s ^= s >> 19\n; rng_state = rng_state[32..128] .. t ^ s\n;\n; To do this simultaneuosly and in parallel, we want to compute:\n; rng_state = rng_state[32..128] .. (\n;   rng_state[96..128] ^ rng_state[96..109]       ; s ^ (s >> 19)\n; ^ rng_state[0..32] ^ (rng_state[11..32] << 11)  ; t ^ (t << 11)\n; ^ rng_state[0..24] ^ (rng_state[11..32] << 3)   ; (t ^ (t << 11)) >> 8\n; )\n; We align each of those into 4-bit aligned chunks and compute each chunk separately\n; by using the 4x4 bit xor table to compute the xors, concatenating them at the end.\n; Each index here is the base, extending +4 (or sometimes fewer) bits.\n;  96 100 104 108 112 116 120 124\n;   -   -   -   -  96  97 101 105\n;   0   4   8  12  16  20  24  28\n;  11  15  19  23  27  31   -   -\n;   -   -   0   4   8  12  16  20\n;   -   -  11  15  19  23  27  31\n{lua(function rng_codeCacheSetNext(cache)\\\n--[[\\\nTo construct a single 4-bit term in the formula, we pass this varargs function the offsets\\\nfrom a column in the table above, and the last value indicates the number of bits for the\\\npartial term. Some chunks can be made entirely with 4-bit terms, but others have a partial\\\nterm made with a smaller number of bits. Thankfully, there is at most one of these per chunk.\\\nWe use a positive value to indicate a term that needs padding on the left, and a negative\\\nvalue to indicate a term that needs padding on the right.\\\n\\\nWe directly place each component in an accumulator array, to join them at the end.\\\nThe indexing is a little complicated; This example shows how the indices work out for args=3.\\\n       1    2       3     4    5       6     7    8 9 \\\n      lsg( sub() .\"xor\". lsg( sub() .\"xor\". sub() ) ) \\\n]]\\\n  local function singleTerm(...)\\\n    local inp = table.pack(...)\\\n    local args = inp.n - 1\\\n    local res = {}\\\n    for i = 1, args-1 do\\\n      res[i*3-2] = \"{rng_local}.string.get(\"\\\n      res[i*3-1] = string.format(\"sub(rng_state,%d,4)\", inp[i])\\\n      res[i*3] = [[.\"xor\".]]\\\n      res[args*3+i-2] = \")\"\\\n    end\\\n    if inp[args+1] > 0 then\\\n      res[args*3-3] = [[.\"xor]] .. string.rep(\"0\", 4 - inp[args+1]) .. [[\".]]\\\n      res[args*3-2] = string.format(\"sub(rng_state,%d,%d)\", inp[args], inp[args+1])\\\n    else\\\n      res[args*3-3] = [[.\"]] .. string.rep(\"0\", 4 + inp[args+1]) .. [[xor\".]]\\\n      res[args*3-2] = res[args*3-4]\\\n      res[args*3-4] = string.format(\"sub(rng_state,%d,%d)\", inp[args], -inp[args+1])\\\n    end\\\n    return table.concat(res)\\\n  end\\\n\\\n  res = {}\\\n  res[1] = singleTerm( 96,  0,     11,               4)\\\n  res[2] = singleTerm(100,  4,     15,               4)\\\n  res[3] = singleTerm(104,  8,  0, 19, 11,           4)\\\n  res[4] = singleTerm(108, 12,  4, 23, 15,           4)\\\n  res[5] = singleTerm(112, 16,  8, 27, 19, 96,       1)\\\n  res[6] = singleTerm(116, 20, 12,     23, 97,  31, -1)\\\n  res[7] = singleTerm(120, 24, 16,     27, 101,      4)\\\n  res[8] = singleTerm(124, 28, 20,         105, 31, -1)\\\n  cache[\"next\"] = \"rng_state = sub(rng_state, 32, 96) . \" .. table.concat(res, \" . \")\\\n;end\\\n)}\n\n{lua(function rng_getrange(min, max)\\\n  local nmin = tonumber(min)\\\n  local nmax = tonumber(max)\\\n  local range\\\n  if nmin and nmax then\\\n    range = string.format(\"%.1f\", nmax + 0.0 - nmin + 1)\\\n  else\\\n    range = string.format([[(i2d(%s) - i2d(%s) + 1.)]], max, min)\\\n  end\\\n  local modpart = string.format([[%s %% %s]], rng_codecache.getdouble, range)\\\n  if nmin then\\\n    if nmin == 0 then\\\n      return \"d2i(\" .. modpart .. \")\"\\\n    end\\\n    return string.format(\"d2i(%.1f + %s)\", nmin, modpart)\\\n  end\\\n  return string.format(\"d2i(i2d(%s) + %s)\", min, modpart)\\\n;end\\\n)}\n\n; Return the appropriate code (macro body) given the passed in \"id\". All this does is lookup\n; the precomputed code and return that; if the code hasn't been computed yet, it calls the\n; helper functions tha exist specifically to set that up.\n; The one wrinkle is that the 3rd init macro has a parameter, and that is substituted in\n; to the cached code here.\n{lua(function rng_code(id, label, arg2)\\\n  if not rng_codecache then\\\n    rng_codecache = {}\\\n    rng_codeCacheSetInit(rng_codecache)\\\n    rng_codeCacheSetNext(rng_codecache)\\\n    rng_codeCacheSetGetInt(rng_codecache)\\\n  end\\\n  if id == \"getrange\" then\\\n    return rng_getrange(label, arg2)\\\n  end\\\n  local res = rng_codecache[id]\\\n  if label then\\\n    return res:gsub(\"EXTERNAL_LABEL\", label)\\\n  end\\\n  return res\\\n;end\\\n)}\n"],["rng_tester","key.t()\n\n:import rnglib\n:budget_cap max\n\n:global int predicted_rng\n:global int actual_rng\n\n{rng_init1}\n{rng_init2}\n{rng_init3(guess)}\n\nguess:\n{rng_next}\npredicted_rng = {rng_getrange(0, 999999)}\nactual_rng = rnd(0, 999999)\n"],["D0S.RakStak","wakeup()\ngame.newround()\n\nisTowerTesting()\n\n:import rnglib\n:budget_cap max\n\n:local int rak_count\n:local double waveCount\n:global string rak_status\n\ngotoif(exit, contains(rak_status, \"running\"))\nrak_status = \"0;running\"\ngoto(if(\\\n  active.index(\"spell.raksCurse\") == 0,\\\n  end,\\\n  wait_for_rak\\\n))\n\ndo_rak:\nuseinstant(active.index(\"spell.raksCurse\"))\n; Don't increment if we didn't have mana\nrak_count += if(cooldown(active.index(\"spell.raksCurse\")) > 0., 1, 0)\nrak_status = rak_count . \";running\"\n\n#rawWaves (infinity() * 1e11 + era()) * 1e11 + wave()\nwait_for_rak:\nwaveCount = {rawWaves}\nwaitframe()\n; Abort if we exited or restarted or are finished with stacks\ngoto(if(\\\n  health(false) == 0. || {rawWaves} < waveCount || contains(rak_status, \"5\"),\\\n  end,\\\n  if(\\\n    cooldown(active.index(\"spell.raksCurse\")) == 0.,\\\n    rng_reinit,\\\n    wait_for_rak\\\n  )\\\n))\n\n{rng_init1}\n{rng_init2}\n{rng_init3(guess)}\n\nguess:\n{rng_next}\ngoto(if(\\\n  {rng_getrange(0, 999)} == 0,\\\n  do_rak,\\\n  guess + rnd(0, 0)\\\n))\\\n\nend:\nrak_status = sub(rak_status, 0, 1)\nexit:\n"]]}}
```
