:import factory constants

:name {script_name(init)}

wakeup()
open.factory()

isopen("factory")

:global double factory_target_amount
:global int factory_target

:global int turbo.cycles
:global int turbo.cycles.max

:local double target_value

; Run the UI, to display the current pending item.
execute("{script_name(ui)}")

; Initial dispatch on entering the factory to determine if we are resuming
; a crafting operation or waiting to launch a new one. This is done outside
; of turbo, so that we never invoke turbo if we don't need to.
gotoif(wait_loop, {get_raw(factory_target)} == 0.)

; The core factory cycle. We do each loop of factory production within
; one call of nested turbo start/stop, which executes within one frame.
;
; This loop handles both calculating recipes via "run_recipes"
; and crafting via "craft". This is done with conditional execution,
; in order to save lines for future possible features.
begin_cycle:
executesync("turbo start")

; Here we up the number of cycles so that it will be enough to
; calculate the recipes or produce items. We intentionally have a
; frame break between the recipe calculation and the beginning of crafting
; to prevent jarring lag on startup.
; This formula ensures that we don't accidentally step on another script
; that needs more cycles, and also that we get the full amount of cycles
; even if something else started turbo before us.
turbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)

; We have to save this, because the value can change as a result of executing
; later scripts.
target_value = {get_raw(factory_target)}

; All conditional execution in the loop is behind this condition. If it
; is true, then we're here because of `ui`. Otherwise,
; this is a regular crafting iteration.
executesync(if(target_value <= 0., "{script_name(run_recipes)}", "{script_name(produce)}"))
stop(if(target_value <= 0., "{script_name(run_recipes)}", "{script_name(produce)}"))
executesync(if(target_value <= 0., "", "{script_name(craft)}"))
stop(if(target_value <= 0., "", "{script_name(craft)}"))

; Clear factory_target to indicate that crafting is done, if it is, in fact, done.
factory_target = if({get_raw(factory_target)} <= 0., 0, factory_target)
; Re-display the UI when crafting is done.
execute(if(factory_target == 0, "{script_name(ui)}", ""))

; Clear this (unconditionally), to signal that we're not starting a new crafting
; pass.
factory_target_amount = 0.

executesync("turbo stop")

; Here we either return to the next iteration of the production loop,
; or stall on this instruction until we need to launch the factory.
; Because there is always 1 extra cycle of turbo after "turbo stop," there
; is enough time to execute this goto and have only a single frame break
; before starting turbo again at the top of the loop.
wait_loop:
gotoif(\
  if(max(factory_target_amount, {get_raw(factory_target)}) > 0.,\
    begin_cycle, wait_loop\
  ),\
  isopen("factory")\
)

; Remove the UI status so it doesn't clutter the variables when we're outside the
; factory.
; This is safe to repeat, when turbo is looping at the end of the script.
gss({status}, "</size>")
