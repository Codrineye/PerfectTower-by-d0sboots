:import factory constants

:name {script_name(launch factory craft)}

:global int factory_target
:global double factory_target_amount
:global string factory_launch

:global int turbo.cycles.max

:local int target_tier
:local string target_type
:local double target_amount

key.f()

isopen("factory")

; Concatenates the names of all the items, in brackets to ensure that
; searching for them finds the correct unique result. Also throws in the
; in-game names so that you can refer to items that way if you want.
#item_names {lua(\
  local acc = {};\
  --[[Save two space for the surrounding brackets]]\
  local size = math.max(factory.name_max_size,\
    factory.game_name_sizes.item,\
    factory.game_name_sizes.craft) + 2;\
  local fmt = "%-" .. size .. "s";\
  acc[1] = '"';\
  for i = 1, #factory.items do\
    acc[#acc + 1] = string.format(fmt, "[" .. factory.items[i].game_name .. "]");\
  end\
  for i = 1, #factory.items do\
    acc[#acc + 1] = string.format(fmt, "[" .. factory.items[i].name .. "]");\
  end\
  acc[#acc + 1] = '"';\
  factory.entry_size = size;\
  return table.concat(acc);\
)}
#tier_data {lua(\
  local acc = {};\
  acc[1] = '"';\
  for i = 1, #factory.items do\
    acc[#acc + 1] = string.format("%d", factory.items[i].tier - 1);\
  end\
  acc[#acc + 1] = '"';\
  return table.concat(acc);\
)}

#entry_size {lua(return factory.entry_size)}

; Begin turbo. This lets us detect if it actually exists and gets through
; the remainder of this script quickly.
executesync("turbo start")

; A gap to visually separate the parameters from the code
; above. "local.unset" is the shortest 1-parameter action when viewed in
; the editor.
local.unset(" ")

target_tier = 1
target_type = "set item type here"
target_amount = 8.

; Begin a block that will hide the rest of the global variables from view.
; This also conveniently shows as empty space in the in-game editor.
gss("<size=0>fhide", "")

factory_target_amount = target_amount

; This sets the target, i.e. the combined item/tier expression, by finding
; the appropriate string in the item_names data table. Because the names
; repeate twice (once for the "Xenos" name, once with the in-game name),
; we use % to put it in the proper range. Mod is truncating in this game, which
; means that a -1 result from "not found" will remain as -1.
; The remainder of this expression multiplies the item by 10 and adds in the
; tier. The odd ordering is so that a -1 result will cause the item to
; round down, instead of truncating to zero.
factory_target = ((index({item_names}, "[" . target_type . "]", 0)\
  % ({lua(return #factory.items)} * {entry_size}) + {entry_size}) * 10) / {entry_size} + target_tier - 1

; We re-use the same strings for both factory_launch and error. This is
; because both end with </size>, so both can close the size block, but
; error has a built-in <size=20> in the variable name so it's only closing
; a local block.
;
; Doing things this way pushes two instructions after we set this, which
; is needed for timing reasons.
factory_launch =\
  if(turbo.cycles.max == 0,\
    "Needs turbo exec v2!</size>",\
    if(target_type == "", "You likely changed the name of target_type instead of the value, please re-import.</size>",\
      if(target_type == "set item type here", "You need to set the values in <color=yellow>launch factory craft</color>. If you don't know the names of items, see <color=green>factory_constants.tpt2</color>, which is linked on the github.</size>",\
        if(factory_target - target_tier < 9, "Invalid item '" . target_type . "'</size>",\
          if(target_tier < 1, "Tier " . target_tier . " < 1</size>",\
            if(target_tier > index(" 0123456789", sub(" " . {tier_data}, factory_target / 10, 1), 0),\
              "Tier " . target_tier . " too big</size>",\
              "go</size>"\
            )\
          )\
        )\
      )\
    )\
  )
; For error, we also need to close a <color> block.
gss({error}, factory_launch . "</color>")
global.unset(if(factory_launch == "go</size>", {error}, ""))

; "init" will take over as soon as factory_launch gets set 3 lines
; above; it will call its own "turbo start" and thus prevent the frame from
; ending before this "turbo stop" takes effect.
; We need two cycles in-between to have a seamless transition.
; If the error is "Invalid item", then we invoke "fix target typo" to find
; a potential near-match; it will be responsible for ending turbo.
executesync(if(sub(gsg({error}), 0, 12) == "Invalid item",\
  "{script_name(fix target typo)}",\
  "turbo stop"))
; Always need a no-op at the end, because of the extra cycle of turbo boost
; after turbo stop.
wait(0.0)
