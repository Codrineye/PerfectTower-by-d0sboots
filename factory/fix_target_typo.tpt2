:import factory constants

:name {script_name(fix target typo)}

:global int turbo.cycles.max
:local string table
:local string current_word
:local int usr_str_len
:local string test_str
:local int loop_pos
:local int table_pos

;the package error text
#error "<color=white><size=20>error"

; Main data table. This is all the items, delimited by |. It also includes the
; game_names of the items, except when they would be redundant. (Either identical
; to the regular name, or unneeded because the order-swapping we'll do will
; cause it redundant.)
table="{lua(\
  local acc = {};\
  for i = 1, #factory.items do\
    local item = factory.items[i];\
    acc[#acc + 1] = item.name;\
    acc[#acc + 1] = "|";\
    local swapped = item.game_name:gsub("([^.]*)%.(.*)", "%2_%1");\
    if item.craft_type ~= "group" and item.name ~= item.game_name and item.name ~= swapped then\
      acc[#acc + 1] = item.game_name;\
      acc[#acc + 1] = "|";\
    end;\
  end;\
  return table.concat(acc);\
)}"

; We don't have enough lines to store both usr_str and its length. Because
; len(usr_str) is the more-commonly-used value, it's actually better to store
; it, and have characters be extracted from usr_str when needed.
usr_str_len = len(gsg({error})) - 29

; The main loop
find:

current_word = sub(table, table_pos, index(table, "|", table_pos) - table_pos)
; table_pos always points one past the delimiter, at the start of the next word
table_pos = index(table, "|", table_pos) + 1

#max_distance (1 + usr_str_len / 6)

; Avoid the DP loop if it can't possibly match due to length issues
; Use squaring as an ugly form of absolute value.
gotoif(if(table_pos >= len(table) - 1, end, find),\
  (usr_str_len - 1 - len(current_word))^2 > {max_distance}^2\
)

; We operate on current_word twice: Once "flipped", and once normal. The flipped
; version is mirrored around either "." or "_", so stacked_plate becomes
; "plate_stacked", for instance. We stop the (short) loop when
; test_str == current_word, so either 2 iterations or 1 when there wasn't anything
; to flip at all.
; "Wasting" an instruction by setting test_str twice like this is the simplest
; way to accomplish this.
test_str = current_word

; Jump here for next iteration, as opposed to an entirely new word
next_loop:
; We have to keep resetting this, because when we go over the max cycles it
; gets reset to a low value. We want the value to be large, but not *too* large,
; so that the game stays somewhat responsive.
turbo.cycles.max = max(turbo.cycles.max, 3000)

; We swap the terms around by using subscripting.
test_str = if(\
  contains(test_str, "_"),\
  sub(test_str, index(test_str, "_", 0) + 1, 99) . "_" . sub(test_str, 0, index(test_str, "_", 0)),\
  if(\
    contains(test_str, "."),\
    sub(test_str, index(test_str, ".", 0) + 1, 99) . "." . sub(test_str, 0, index(test_str, ".", 0)),\
    test_str\
  )\
)

#lookup(i) lig("arr" . ({i}))

; The dynammic programming loop.
; We construct an array in "arr". It's a two-dimensional array, but it's indexed
; and iterated linearly in one dimension. Conceptually, each column corresponds
; to entries in usr_str, and each row to entries in test_str, such that for
; usr_str[i] and test_str[j], we lookup arr[j*len(usr_str) + i]. This is with
; the augmentation that the first element of usr_str is always a dummy character,
; because the algorithm requires the 0th row and column to be treated specially.
;
; The actuall DP method assigns the value of (i-1, j-1) to position (i, j) if
; usr_str[i] == test_str[j], otherwise (i, j) becomes one plus the smaller of
; (i-1, j) and (i, j-1). (0, 0) is initialized to 0, and this implies that the
; first row and column will always strictly increment. Thus, after initializing
; the beginning initially, we can skip it on subsequent rounds (by never
; resetting loop_pos fully to 0).
;
; By being clever with our indexing math and expressions, we can avoid needing
; special case handling most of the time.
loop:
lis("arr" . loop_pos,\
  if(loop_pos < usr_str_len,\
     loop_pos,\
     if(sub(gsg({error}), 13 + loop_pos % usr_str_len, 1) == sub(test_str, loop_pos / usr_str_len - 1, 1),\
        {lookup(loop_pos - usr_str_len - 1)},\
        min(min(\
          {lookup(loop_pos - usr_str_len - 1)},\
          {lookup(loop_pos - usr_str_len)}),\
          {lookup(loop_pos - 1)}\
        ) + 1\
     )\
  )\
)
loop_pos = loop_pos + 1
gotoif(loop, loop_pos < usr_str_len * (len(test_str) + 1))
; Skip the beginning row and first column, which never change.
loop_pos = usr_str_len + 1

; We jump to end here, because we need to put on the trailing text still.
end:
gss({error}, sub(gsg({error}), 0, len(gsg({error})) - 15) .\
  if(sub(gsg({error}), len(gsg({error})) - 16, 1) == "'",\
    "<br><color=yellow>Suggested alternatives:</color><br>",\
    ""\
  ) .\
  if({lookup(1)} != 1 || {lookup(usr_str_len * (len(test_str) + 1) - 1)} > {max_distance},\
     "",\
     current_word . "<br>"\
  ) .\
  if(table_pos < len(table) - 1,\
     "",\
     "<color=yellow>No other results found.</color><br>If this isn't helping, read the <color=green>readme.md</color> in github!"\
  ) .\
  "</size></color>"\
)

gotoif(if(test_str == current_word, find, next_loop), table_pos < len(table) - 1)

executesync("turbo stop")
wait(0.0)
