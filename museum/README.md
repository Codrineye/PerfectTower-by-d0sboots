# Museum Source Code

This is the source directory for the museum. This document explains how to make changes.
To download and use the package, [go up a level](/README.md#museum-combiner-v3).

## Making changes

Modifying the code requires the enchanced editor at https://d0sboots.github.io/perfect-tower, because it
`:import`s some scripts to use as macro libraries.

The editor has a source-import feature, used the same way you import scripts.
The following will set up a new workspace for the museum:
```
{"workspaces":{"museum2":[["museum_macros","; Standardized (package) naming across all the scripts\n#script(name) D0S.Museum v3.1:{name}\n\n; Keybindings. You can edit these here, or edit them in the scripts directly\n; (but it will be much more error-prone).\n#up w\n#down s\n#start m\n\n; Name of the budget variable, which begins the script-hiding block.\n#budget \"<size=0>mb**\"\n"],["Buy",":import museum_macros\n:name {script(Buy)}\n\n; This isn't included in this subdirectory, but comes from the factory/ directory.\n:import worker_storage_lib\n\n; This script is responsible for buying from the regular market.\n;\n; It also contains initialization logic for variables. They must be set in the\n; proper order, so that the remain hidden inside our <size=0> block. This also\n; reads/writes the budget from worker storage, and increment/decrements it\n; if the right keys are pressed.\n\nkey.{up}()\nkey.{down}()\n\nisopen(\"museum\")\n\n:global string museum_status\n:global int museum_tier\n:global int target_tier\n:global int museum_pos\n\n:global int turbo.register\n:global int turbo.cycles\n\n:local string local_buy\n:local double worker_val\n\n; If we're being called from Combine, we're a buyer.\n; Otherwise, if we're being invoked due to key-impulse, but the combiner is\n; currently running, abort. We don't want to change the budget in the middle\n; of things.\ngoto(if(\\\n  contains(\"{script(Combine)}\", impulse()),\\\n  buy,\\\n  if(\\\n    contains(\"key.{up}|key.{down}\", impulse()) &&\\\n      contains(museum_status, \"Combining\"),\\\n    end,\\\n    init\\\n  )\\\n))\n\ninit:\n\n; We direct-start turbo, to avoid extra scripts causing lag.\nturbo.register += 1\n\n; Use worker_storage_lib to find a worker_slot to use for permanent storage.\n#prefix [museum]\n:local int worker_slot\n{worker_lib_line_1({prefix})}\n{worker_lib_line_2}\n\n; Fetch the budget from the chosen worker. The s2d fallback handles the case\n; where we're allocating new storage, as well.\nworker_val = s2d(sub(worker.name(worker_slot), {len({prefix})}, 99), 1e11)\n\n; Ensure this value is set before we start hiding variables.\n; If we're launching on wakeup(), the other turbo variables will get set\n; in time, but this one might not.\nturbo.cycles = turbo.cycles\n\n; If we're incrementing or decrementing the budget, round it to a fixed\n; amount. This allows users to set it to a specific amount by modifying the\n; worker if they wish, but we'll always get clean set-points when changing\n; via the UI.\n; The lower bound is 1e5, since at that point you can't buy any stones\n; (according to our budget).\n; Also, set budget to -1 if there are no worker slots available. This is our\n; signal to Main, so that it can display an appropriate error message.\ngds({budget}, if(\\\n  worker_slot == 200,\\\n  -1.,\\\n  if(\\\n    contains(impulse(), \"key.\"),\\\n    (10. ^ 0.5) ^ max(10., \\\n      round(worker_val // (10. ^ 0.5)) +\\\n      if(contains(impulse(), \"key.{up}\"), 1., -1.)\\\n    ),\\\n    worker_val\\\n  )\\\n))\n; Save the budget back. There's always enough room for the full value.\nworker.setName(\\\n  worker_slot - if(worker_slot < 100, 0, 100),\\\n  \"{prefix}\" . gdg({budget})\\\n)\n\n; Set other variables that need to happen before we close the script block.\nmuseum_tier = museum_tier\nmuseum_pos = -1\n\n; Signal Main to wake up. We only want to override target_tier if it's idle,\n; i.e. set to 0 - other situations show that it's in use, and notifying about\n; changing budget is the lowest priority.\ntarget_tier = if(target_tier == 0, -3, target_tier)\n\n; We don't care about waiting for the frame break, so manipulate the value\n; directly instead of using \"turbo stop\".\n; This also gives some (useful) extra turbo frames to our caller, Main.\nturbo.register -= 1\n\nbuy:\n; If we're a buyer, use the stone in inventory.\n; Otherwise, buy nothing until we can exit normally.\nlocal_buy = if(\\\n  contains(\"{script(Combine)}\", impulse()),\\\n  element(\"inventory\", 0),\\\n  \"\"\\\n)\n\n; Because of turbo exec, this script will keep running every cycle, until\n; the frame pause. At that point, it will exit, and we rely on Combine to\n; restart it.\n;\n; Everything is very carefully engineered to make this expression as minimal\n; as possible. It's worth spending extra cycles in set-up in order to remove\n; a single node from this expression.\nbuy(local_buy)\n\nend:\n"],["Combine",":import museum_macros\n:name {script(Combine)}\n\n; This script is responsible for actually combining gems.\n;\n; That's true in two senses: It both has the actual call to Combine(), and\n; also the logic immediately surrounding it that runs the combines and checks\n; to see if the loop is done.\n\n:global int museum_tier\n:global int target_tier\n\n:global int turbo.cycles.max\n:global int turbo.cycles\n:global int turbo.register\n\n; If we're invoking ourselves, we're a dedicated Combine()er.\n; Otherwise, check to see if we've already reached our goal.\n; If we have, we can exit early, otherwise fall through to the main logic.\ngoto(if(\\\n  contains(impulse(), \"{script(Combine)}\"),\\\n  combine,\\\n  if(tier(\"inventory\", 0) >= target_tier, done, start)\\\n))\nstart:\n\n; Stop our parent. Although buying from the market might be what we need, it\n; would be in the wrong order relative to combines.\nstop(\"{script(BuyOffshore)}\")\n\n; Keep restarting the buy and combine scripts whenever the turbo frame ends.\n; They rely on the 1-cycle-end-of-script-loop property of turbo to function,\n; so we also keep the cycle max up for efficiency.\nrestart_loop:\n\n; We start 3 copies of combine, because each combine only combines 3 gems.\n; (As opposed to when you do it manually: then it does 2 combines, once on\n; mousedown and one on mouseup.) 3 is roughly optimal: there are very few\n; positions the inventory can be in that don't support 3 combines between buys,\n; whereas there are significantly more for 4. And combine is one of the most\n; time-expensive operations in the loop, so we don't want to run it pointlessly.\nexecute(\"{script(Combine)}\")\nexecute(\"{script(Combine)}\")\nexecute(\"{script(Combine)}\")\n\n; Start the correct buyer. Buy running this after the combiners, we'll always\n; end each cycle with a full inventory, which is important for the check below.\n#correct_buyer if(\\\n  contains(element(\"inventory\", 0), \"universal\") || museum_tier != 1,\\\n  \"{script(BuyOffshore)}\",\\\n  \"{script(Buy)}\"\\\n)\nexecute({correct_buyer})\n\n; Extend the max duration. There is a possible race condition where we might\n; already be exiting turbo due to being at too many cycles; this is death with\n; (and discussed more) in BuyOffshore. We can never be in the race condition\n; internally, because it does not take nearly 200 cycles to get from the\n; \"turbo stop\" to this line.\nturbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 1050)\n\n; The core condition to wait for. This condition needs to be as minimal as\n; possible, because it is draining CPU time away from the important combine/buy\n; tasks every cycle. (So is the turbo exec machinery, but we can't help that.)\nwaituntil(tier(\"inventory\", 0) >= target_tier || turbo.cycles >= 1000)\n\n; If we are done, stop the buyers ASAP, to avoid wasting money. The condition\n; here relies on the condition above for correctness, but is simpler.\n; (Technically there's an edge case if it finishes right at the end, but the\n; number of cycles required means that won't happen.)\nstop(if(turbo.cycles >= 1000, \"\", {correct_buyer}))\n\n; We restart turbo by changing the variable directly, so that there isn't a\n; \"turbo start\" script taking up cycles. In comparison, we stop turbo with\n; executesync(), because we want to block until the end of the frame, and\n; the end of the frame will naturally clean up the script.\nexecutesync(\"turbo stop\")\nturbo.register += 1\n\n; Do another loop if we're not done yet.\n; Abort if the 3rd-to-last power stone is not the tier we expect it to be.\n; Because Buy(Offshore) runs after the combines, and won't have been stopped\n; in the case where we're not done yet, we can expect the \"fill inventory\" buy\n; to have left the final position with our target tier. Checking this way\n; catches both museum rollover and out-of-resources.\n;\n; The reason for checking the 3rd-to-last slot, and not the last slot, has to\n; do with the way combine processing is run: It starts checking for combinable\n; stuff from the first slot down. So it's possible for two base-tier stones to\n; be left in the last two slots, but there can't be *3* in the last 3, because\n; they would be combine-eligible. *Unless* they were just bought. (This isn't\n; quite true, because the combines might be occupied with higher-tier stones,\n; but if we've exausted resources or had rollover, it will rapidly become true.)\n;\n; This also interacts in predictable ways with another couple of common issues:\n; lacking the \"quick combine\" skill and not having all the inventory slots.\n; If all the slots aren't purchased, this condition will always fail immediately.\n; The symptom will be that the combiners seems to \"never do anything.\"\n; Conversely, without quick combine no progress will ever be made. As soon\n; as a power stone is hit that needs fast leveling, it will get \"stuck\" there.\n; This is a sure sign of lacking quick-combine.\n;\n; If we are doing a \"careful\" combine without fill-inventory, it shouldn't take\n; more than 1000 cycles, so this condition won't be a problem.\ngotoif(restart_loop,\\\n  tier(\"inventory\", 0) < target_tier && tier(\"inventory\", 21) == museum_tier)\n\ndone:\n; In case we jumped here directly.\nstop(\"{script(BuyOffshore)}\")\n\n; This is the signal for Main that it should continue.\nmuseum_tier = -1\n\n; Now that we're done, move the finished stone back to \"equipped\". This also\n; moves partial/original stones back, if we cancelled via {start}.\n; This won't preserve order if there were spaces - everything will get\n; crunched together. Fixing this is technically possible, but very challenging\n; and just not worth it.\n;\n; Even though this happens after signalling, we get one extra cycle as a\n; \"delay slot\" before we're stopped by Main.\nmove(\"inventory\", 0, \"equipped\")\n\ncombine:\n; Because of turbo exec, this script will keep running every cycle, until\n; the frame pause. At that point, it will exit, and we rely on Combine to\n; restart it.\n\n; There's no point in using a variable for the combine limit; halting the\n; combines is handled by the end of turbo. Having the limit be a constant\n; removes one node from the hottest execution path.\ncombine(50)\n"],["BuyOffshore",":import museum_macros\n:name {script(BuyOffshore)}\n\n; This script is responsible for buying from the offshore market.\n;\n; It also contains (stub) logic for handling key.{start}. This would be part\n; of Main normally, but there can only be 2 impulses per script at the\n; resource-cost-levels we're targeting.\n;\n; The final (bulk) of the logic deals with buying test stones from the\n; offshore market and doing calculations/preparations for the actual\n; combining, which is handled by Combine. This script sets museum_tier\n; and target_tier, which directly drive the combining process.\n\nkey.{start}()\n\n:global int museum_tier\n:global int target_tier\n:global int museum_pos\n:global double budget\n\n:global int turbo.register\n:global int turbo.cycles\n:global int turbo.cycles.max\n\n:local int max_craft_tier\n:local string local_buy\n\n; Dispatch to the correct logic.\n; * If we're called from Combine, we're running as a Buyer.\n; * Otherwise, if we're called from key.{start}, then check if the museum\n;   is open. If it is, signal Main, otherwise exit. We can't just set a\n;   condition on the script, because that would possibly mess up scripts\n;   that execute us, on exiting the museum.\n; * Otherwise, we're called from Main, and are falling through to\n;   combine set-up.\ngotoif(\\\n  if(\\\n    contains(\"{script(Combine)}\", impulse()),\\\n    buy,\\\n    if(isopen(\"museum\"), button, end)\\\n  ),\\\n  contains(\"{script(Combine)}|key.{start}\", impulse())\\\n)\n\n; This local can be changed to set a ceiling on crafting.\n; Its only purpose is for getting all gems to the same level so they can\n; be transmuted with the cube; otherwise, this should be left at 50.\n; Usually it's better to just wait for Universal gems to show up in the\n; market, but if you're desperate, you can try this.\nmax_craft_tier = 50\n\n; Only buy one of the expensive market gems to test with.\nfill(false)\nclear(\"inventory\")\n\n; Buy a test gem from the market, to tell us what's available for upgrading\n; this element. The max tier is determined from our budget; we calculate it\n; so that at most 1% of our budget is spent on test gems, assuming 100 power\n; stones. (It will usually be much less, because of rounding and the random\n; chance of stone tiers.)\n; It's fine to miss out on some over-leveled gems in the market;\n; they are never the ones that will lead to the highest-leveled gems after\n; upgrading, anyway (when considering our budget).\nbuyMarket(element(\"equipped\", museum_pos),\\\n  d2i((gdg({budget}) / (2000. * 10000. / 18.)) // 18.))\n\n; Macro for determining the number of tiers we can boost, given our budget and\n; stones of \"in_tier\".\n; We allocate 1% of budget to each stone. Based on the tier of the stones we\n; can buy, they cost 2000 * 18^in_tier / 18 each. (We ignore the extra cost\n; of universal stones.) This determines how many stones we can buy, and thus,\n; the max tier.\n; \"offset\" is a way of adding an additional factor of \"in_tier\" to the\n; expression as a constant factor. Doing this changes the meaning from\n; the number of tiers raised to the maximum tier attainable.\n#up_tiers(in_tier, offset) d2i((gdg({budget}) / (100. * 2000. / 18.)) // 3. - i2d({in_tier}) * (18. // 3. - {offset}))\n\n; Set the tier of stones we are buying.\n; Typically, this is the tier we can get from the offshore market (as determined\n; from test-stone buying), or 1 to denote regular buying if the stones aren't\n; available right now from offshore.\n; However, there is a quirk at lower tiers: If we will only be able to upgrade\n; to tier 12 (or less) using the offshore market, it is always better to use\n; regular stones.\nmuseum_tier = if(\\\n  contains(element(\"equipped\", museum_pos), \"universal\") ||\\\n    {up_tiers(tier(\"inventory\", 0), 1)} > 12,\\\n  max(\\\n    tier(\"inventory\", 0),\\\n    if(\\\n      contains(element(\"equipped\", museum_pos), \"universal\"),\\\n      -1,\\\n      1\\\n    )\\\n  ),\\\n  1\\\n)\n\n; Determine \"target_tier\", the level we are trying to upgrade to. In the\n; best case, we can upgrade 11 levels past the tier of the stones we can\n; buy from the museum. (Which may only be tier 1.)\n;\n; Because of how test gems are bought, they should always be at least 100x\n; cheaper than our budget, meaning target_tier should be at least 4 levels\n; greater than museum_tier.\ntarget_tier = if(min(tier(\"equipped\", museum_pos), museum_tier) < 0,\\\n  -1,\\\n  min(max_craft_tier,\\\n    min(11, {up_tiers(museum_tier, 0)}) + museum_tier\\\n  )\\\n)\n; There are a couple of different conditions here.\n; If tier(museum_pos) >= target_tier, we want to get rid of the test stone, so\n; that our stone goes to slot 0. That way the loop will end immediately.\n; If tier(museum_pos) < museum_tier, we want to get rid of *our* stone, because\n; it's too low level and can't be combined with.\n; Otherwise, it's potentially useful to help speed up the process.\ndelete(\\\n  if(tier(\"equipped\", museum_pos) >= target_tier, \"inventory\", \"equipped\"),\\\n  if(\\\n    tier(\"equipped\", museum_pos) >= target_tier,\\\n    0,\\\n    if(tier(\"equipped\", museum_pos) < museum_tier, museum_pos, -1)\\\n  )\\\n)\nmove(\"equipped\", museum_pos, \"inventory\")\n\n; If we're only upgrading 6 or fewer levels, we buy one-at-a-time to avoid\n; overbuying. The number of operations is so small that it won't be slow.\nfill(target_tier - museum_tier > 6)\n\n; Extend turbo for a little longer. There's a race condition where we might\n; run out of cycles and start a new frame, but even if we do that on this\n; line, the new frame will start in time for the Combiners to loop properly,\n; and for the max-setting line in Combine to set the max to its proper value.\n;\n; Otherwise, this ensures that we stay in the current loop until the line\n; in Combine sets cycles.max to its full value.\n; This is a small enough extension so that if we never enter the main loop\n; of Combine, we'll still eventually hit turbo.cycles.max and start a new frame.\n; (I.e. we can't loop indefinitely with this extension alone.)\nturbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 15)\n\n; executesync() is used here to pause us until our child Combine stops us.\nexecutesync(\"{script(Combine)}\")\n\n; We jump here from the top when key.{start} is pressed.\nbutton:\n; Signal Main. This will overwrite target_tier if we are currently combining,\n; causing an early exit and leading to main resuming - which is what we\n; want.\ntarget_tier = -2\n\nbuy:\n; If we're a buyer, use the stone in inventory.\n; Otherwise, buy nothing until we can exit normally.\nlocal_buy = if(\\\n  contains(\"{script(Combine)}\", impulse()),\\\n  element(\"inventory\", 0),\\\n  \"\"\\\n)\n\n; Because of turbo exec, this script will keep running every cycle, until\n; the frame pause. At that point, it will exit, and we rely on Combine to\n; restart it.\n;\n; Everything is very carefully engineered to make this expression as minimal\n; as possible. It's worth spending extra cycles in set-up in order to remove\n; a single node from this expression.\nbuyMarket(local_buy, museum_tier)\nend:\n"],["Main",":import museum_macros\n:name {script(Main)}\n\n; The \"main\" script of the combiner. It starts on wakeup/entry into the\n; museum, and keeps running until the user leaves the museum. This is because\n; it is responsible for maintaining the UI global \"museum_status\", which\n; both conveys information to the user and also ends a <size=0> block that\n; hides our internal global variables. When we leave the museum, this is\n; set to \"</size>\" to blank the display and leave no clutter.\n;\n; This script also runs the outer part of the loop, which updates the\n; position of the combiner. It is well-suited to this, because it is the\n; only script that doesn't get stop()'ed at some point.\n\n:global int max_craft_tier\n:global int museum_pos\n\n:global string museum_status\n:global int museum_tier\n:global int target_tier\n\n:global int turbo.cycles\n:global int turbo.register\n\n:local double go_time\n\nwakeup()\nopen.museum()\n\nisopen(\"museum\")\n\ntop:\n; Launch Buy to initialize the global variables in the proper order.\n; We re-do this after every run, because it resets museum_pos for us.\nexecutesync(\"{script(Buy)}\")\n\n; This loop usually runs without turbo, although it can have lingering\n; turbo from other scripts without bad effects. It keeps the status line\n; up-to-date while the museum is not running.\nstatus_loop:\n; We use target_tier to receive signals from other scripts. 0 means nothing\n; is hapenning, so we always reset to 0 at the top.\ntarget_tier = 0\n\n; This is a useful sub-expression when displaying numbers in rounded\n; scientific notation. We want to extract the exponent, but for numbers like\n; .9996, we know they'll round up to 1.00 (when rounded to 3 places), so we\n; have to consider them as an exponent higher already.\n; The parameter is to allow for the injection of a constant for constant\n; folding in later expressions.\n#adjusted_exp(x) floor(gdg({budget}) // 10. - (0.9995 // 10. + {x}))\n\n; Stringify the budget in rounded-scientific notation, rounded to 3 digits\n; (2 after the decimal place). This is an awkwardly large expression, but\n; it's really the best we can do with the tools we have.\n; The \"2\" passed to adjusted_exp subtracts 2 from the exponent, so the\n; overall effect is to multiply by 100 (before rounding).\n#rounded_budget round(gdg({budget}) / (10. ^ {adjusted_exp(2.)})) / 100. .\\\n  \"e\". {adjusted_exp(0.)}\n\n; Take the ceiling of time remaining (instead of the floor), so that we tick\n; over to 0 exactly when we cross the threshold, like how countdowns regularly\n; work.\n; The parameter is a divisor, so we can constant-fold the minute division.\n#time_ceil(x) floor((go_time - now() + 10000000.) / (10000000. * {x}))\n\n; Set the status. There's a lot of cases to this:\n; * Error for no workers available.\n;   - We don't have direct visibilty to worker_slot, but Buy will signal the\n;     error by setting budget to negative, which will never happen otherwise.\n; * Error for a bad Turbo install. This is disturbingly frequent.\n; * Show our current budget, with green highlighting to prompt that this\n;   can be adjusted.\n; * Show a brief help line, also with green highlighting to link the keys\n;   to the budget.\n; * If we've pressed {start}, show the Combining message instead. This is\n;   important because certain things key off of it. target_tier = -2 is the\n;   signal for this.\n;\n; We don't bother doing anything special when the museum isn't open, since\n; we'll handle that at the bottom of the script.\nmuseum_status = if(\\\n  gdg({budget}) < 0.,\\\n  \"</size>error=<color=#fb3>No available workers!</color>\",\\\n  if(\\\n    turbo.cycles == 0,\\\n    \"</size>error=<color=#fb3>Turbo exec is not working</color>\",\\\n    \"</size>museum=<color=#2f4>\" .\\\n    {rounded_budget} .\\\n    \"</color> <color=#fff>budget</color><br>\\\n<color=#0df><color=#2f4>{up}</color>/<color=#2f4>{down}</color> changes, <color=#2f4>{start}</color> \" .\\\n    if(\\\n      go_time == 0.,\\\n      \"begins</color>\",\\\n      \"stops</color><br><color=#fff>Waiting \" .\\\n      {time_ceil(60.)} . \":\" . sub(d2s({time_ceil(1.)} % 60. + 100.), 1, 2) .\\\n      \"</color>\"\\\n    )\\\n  )\\\n)\n; The s2i()/sub() expression is a jump-table, where the string values are\n; line numbers.\n; The values that target_tier can have when we get here are 0\n; (if it hasn't been set to anything since it was cleared at the top of\n; status_loop), -2 (set when key.{start} is pressed), and -3 (set when\n; budget is adjusted via key.{up}/key.{down}).\n;\n; -2 finishes the loop. -3 should reset target_tier and update status by\n; jumping two lines back. 0 *could* repeat the same line, except sometimes\n; we have to update status, so we jump one back, to set status.\n; We can't merge the -3 and 0 cases, because setting target_tier over-frequently\n; makes keystrokes flaky.\ngoto(if(\\\n  isopen(\"museum\"),\\\n  if(\\\n    go_time != 0. && now() > go_time,\\\n    start_museum,\\\n    s2i(sub(\"25 3\", target_tier + 3, 1), 99)\\\n  ),\\\n  end\\\n))\n\nstart_museum:\n; Now that we're in the active part of the script, start turbo. We want\n; minimal overhead, so don't execute an extra script, just increment\n; the variable.\nturbo.register += 1\n\n; go_time is the time that we should automatically start the museum again.\n; Initially it is 0, which means the auto-timer is not running. If we get\n; here in that state, we set go_time to be an hour from now, so that when\n; the museum finishes we will start again an hour from when it started\n; (regardless of how long it took to run).\n; Otherwise, if target_tier is -2 then we pressed {start} to cancel the\n; timer, so we set go_time to 0. We will also jump to the bottom of the\n; script to stop turbo and return to the idle loop.\n; The final case handles automatic activation, where we add another hour\n; to the timer.\ngo_time = if(\\\n  go_time == 0.,\\\n  now() + (60. * 60. * 10000000.),\\\n  if(\\\n    target_tier == -2,\\\n    0.,\\\n    go_time + (60. * 60. * 10000000.)\\\n  )\\\n)\ngotoif(stop_turbo, go_time == 0.)\n\nupgrade_loop:\n; Besides recording the tier of stones that can be bought, this also serves\n; as a signal variable. We must reset it to 0 so that we actually wait\n; for BuyOffshore/Combine to be done.\nmuseum_tier = 0\n\n; Go to the next script to perform the actual upgrade.\n; We run this even when museum_pos is -1, in order to set all the variables\n; properly. Combine will exit immediately in that case, without a frame break,\n; so we will fall down below and set the status correctly within the frame\n; that it starts.\nexecute(\"{script(BuyOffshore)}\")\n\n; Combine (which gets run from BuyOffshore) will signal us when it's done.\n; It must be stopped for proper cleanup.\nwaituntil(museum_tier == -1)\nstop(\"{script(Combine)}\")\n\nskip:\nmuseum_pos += 1\n; While running, we have fewer conditions to check, since the errors were\n; already signaled at the top. (There's nothing actually stopping the user\n; from starting the script anyway, but that's on them at that point.)\n;\n; The condition for displaying Combining is reversed, since it's usual\n; here, and if {start} is pressed it means we should exit.\nmuseum_status = \"</size>museum=<color=#2f4>\" .\\\n  {rounded_budget} .\\\n  \"</color> <color=#fff>budget</color><br>\" .\\\n  if(\\\n    target_tier != -2,\\\n    \"<color=#ff0>Combining... [\" . museum_pos . \"] <color=#2f4>{start}</color> stops</color>\",\\\n    \"<color=#0df><color=#2f4>{up}</color>/<color=#2f4>{down}</color> changes, <color=#2f4>{start}</color> begins</color>\"\\\n  )\n\nstop_turbo:\n; Most of the time, we do not want to stop turbo. We only want to do it in\n; the specific cases where we'll be ending the loop. So, this duplicates a lot\n; of the logic in the loop below, all for the benefit of saving a line.\n;\n; Note that if we jumped to stop_turbo directly, museum_status can never\n; contain \"Combining\".\nexecutesync(if(\\\n  isopen(\"museum\") && museum_pos < 130 && contains(museum_status, \"Combining\"),\\\n  \"\",\\\n  \"turbo stop\"\\\n))\n\n; This very complicated gotoif consolidates the ends of lots of loops into\n; one statement.\n; If the museum is closed, fall through to exit the script.\n; If we're through all the positions, or if we're no longer \"Combining\"\n; (which means {start} was pressed), go to the top to reset our state.\n; As a sub-quirk: If we cancelled via {start}, and go_time is still set,\n; jump to start_museum, which won't actually re-start the loop: It will\n; unset go_time instead, and jump back here, where we will finally exit\n; for real.\n; Otherwise, continue the loop: Either normally, or via a shortcut if this\n; part of the grid is empty, to avoid executing the sub-scripts.\ngotoif(\\\n  if(\\\n    museum_pos < 130 && contains(museum_status, \"Combining\"),\\\n    if(tier(\"equipped\", museum_pos) == -1, skip, upgrade_loop),\\\n    if(target_tier == -2 && go_time != 0., start_museum, top)\\\n  ),\\\n  isopen(\"museum\")\\\n)\n\nend:\n; Before we exit, blank the status so that there isn't clutter on the screen.\n; This is safe to do in the last slot because turbo shouldn't be running by\n; this point. Even if it is, we're the only ones who set museum_status, so\n; it's still safe.\nmuseum_status = \"</size>\"\n"]]}}
```

***You will need an additional library to compile, which is part of the factory package: [worker_storage_lib](/factory/worker_storage_lib.tpt2).***

If all you want to do is to change the keybindings, they are located in
`museum_macros`, and you can hit "Export Workspace" to get a bundle code after
changing them.

## Changelog

### v3.1

Fixed several bugs dealing with universal stones and low-level offers in the
offshore market, particularly T1 universals. (Hopefully. I can't test some of
these directly, because my museum is too upgraded.)

### v3.0

Initial release. (Named v3 because the previous version of this name was v2,
but the code was completely different.)
