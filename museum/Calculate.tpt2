:import museum_macros
:name {script(Calculate)}

; This script contains (stub) logic for handling key.{start}. This would be part
; of Main normally, but there can only be 2 impulses per script at the
; resource-cost-levels we're targeting.
;
; The final (bulk) of the logic deals with buying test stones from the
; offshore market and doing calculations/preparations for the actual
; combining, which is handled by Combine. This script sets museum_tier
; and target_tier, which directly drive the combining process.

key.{start}()

:global int museum_tier
:global int target_tier
:global int museum_pos
:global double budget
:global string offer_tiers

:global int turbo.register
:global int turbo.cycles
:global int turbo.cycles.max

; If we're called from key.{start}, then check if the museum
; is open. If it is, signal Main, otherwise exit. We can't just set a
; condition on the script, because that would possibly mess up scripts
; that execute us, on exiting the museum.
; This will overwrite target_tier if we are currently combining,
; causing an early exit and leading to main resuming - which is what we
; want.
; If we're called from Main, then we need to set museum_tier to 0, because it
; serves as a signal variable. Main waits on it for BuyOffshore/Combine to be done.
;
; It's ugly to fold this up into a single conditional set, but between the fact that
; we need museum_tier reset on the first instruction, and some of the other conditions
; involved, it wouldn't be less complicated to do it as two instructions.
global.int.set(\
  if(contains("key.{start}", impulse()), "target_tier", "museum_tier"),\
  if(contains("key.{start}", impulse()),\
    if(isopen("museum"), -2, target_tier),\
    0\
  )\
)
gotoif(end, contains("key.{start}", impulse()))

clear("inventory")


; Load the pre-calculated tier of stone we are buying.
museum_tier = s2i(sub(\
  offer_tiers,\
  {element_to_index_base(element("equipped", museum_pos), "")},\
  2\
), -1)

; Determine "target_tier", the level we are trying to upgrade to. In the
; best case, we can upgrade 11 levels past the tier of the stones we can
; buy from the museum. (Which may only be tier 1.)
target_tier = if(min(tier("equipped", museum_pos), museum_tier) < 0,\
  -1,\
  min(11 + museum_tier, d2i({up_tiers(i2d(museum_tier))}))\
)
; Unless tier(museum_pos) >= target_tier, buy one of the target stone.
; The combiner requires *something* in the inventory to function properly, and
; we might delete the only stone in the next line.
museum.buyTier(\
  element("equipped", museum_pos),\
  museum_tier,\
  if(tier("equipped", museum_pos) >= target_tier, 0, 1)\
)
; If tier(museum_pos) < museum_tier, we want to get rid of our stone, because
; it's too low level and can't be combined with.
; Otherwise, it's potentially useful to help speed up the process.
delete(\
  if(tier("equipped", museum_pos) < museum_tier, "equipped", "inventory"),\
  museum_pos\
)
move("equipped", museum_pos, "inventory")

; Extend turbo for a little longer. There's a race condition where we might
; run out of cycles and start a new frame, but even if we do that on this
; line, the new frame will start in time for the Combiners to loop properly,
; and for the max-setting line in Combine to set the max to its proper value.
;
; Otherwise, this ensures that we stay in the current loop until the line
; in Combine sets cycles.max to its full value.
; This is a small enough extension so that if we never enter the main loop
; of Combine, we'll still eventually hit turbo.cycles.max and start a new frame.
; (I.e. we can't loop indefinitely with this extension alone.)
turbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 15)

; executesync() is used here to pause us until our child Combine stops us.
; If we jump from the top, we have to be prepared to loop back to this instruction.
; in that case, this needs to be a no-op.
executesync(if(contains("key.{start}", impulse()),\
  "%%museum-nop%%",\
  "{script(Combine)}"\
))

end:
